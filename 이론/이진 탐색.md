# 이진 탐색

## 순차 탐색 vs 이진 탐색

순차 탐색 : 리스트 안에 있는 특정한 **데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인**하는 방법
이진 탐색 : 정렬 되어 있는 리스트에서 **탐색 범위를 절반씩 좁혀가며 데이터를 탐색**하는 방법

이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정한다.

## 이진 탐색 동작 예시

이미 정렬된 10개의 데이터 중에서 값이 4인 원소를 찾는 예시

[ 0    1	2	3	4	 5	  6	  7	  8	  9 ]
  0	2	**4**	6	8	10	12	14	16	18

**[Step1] 시작점 : 0 (0), 끝점 : 9 (18), 중간점 : 4 (8) (소수점 이하 제거)**
실제 중간점 인덱스 값인 8과 찾고자 하는 값인 4를 비교해서 어떤 값이 더 큰지를 비교한 뒤에,
찾고자 하는 값보다 현재 중간점 위치의  값이 더 크다면 중간점부터 오른쪽의 값들은 전부다 확인할 필요가 없어진다.
따라서 끝점을 중간점의 왼쪽으로 옮긴다.

**[Step2] 시작점 : 0 (0), 끝점 : 3 (6), 중간점 : 1 (2) (소수점 이하 제거)**
그러면 이처럼 탐색 범위가 네 개로 좁혀진 것을 확인할 수 있다.
현재 중간점의 값은 2이기 때문에 마찬가지로 우리가 찾고자 하는 값을 찾지는 못했다.
다만, 이번에는 중간점의 위치에 있는 값이 2보다 우리가 찾고자 하는 값인 4가 더 크기 때문에
마찬가지로 중간점을 포함해서 왼쪽에 있는 데이터는 볼 필요가 없다.
그래서 시작점 위치를 중간점 오른쪽으로 옮겨준다.

**[Step3] 시작점 : 2 (4), 끝점 : 3 (6), 중간점 : 2 (4) (소수점 이하 제거)**
이때 중간점 위치의 값인 4는 우리가 찾고자 하는 값과 같기 때문에 여기에서 탐색을 마친다.
즉, 우리가 찾고자 하는 값인 4는 인덱스2의 위치에 존재한다는 것을 확인할 수 있고
우리는 총 세번의 step만으로도 우리가 원하는 값이 존재하는지, 그리고 존재한다면 어느 위치에 존재하는지를 
빠르게 알아낼 수 있었다. 

## 이진 탐색의 시간 복잡도

이진 탐색의 시간 복잡도는 기본적으로 탐색 범위를 단계마다 2로 나누는 것이기 때문에 
연산 횟수는 
$$
\log_{2}N
$$
에 비례한다.

예를 들어 초기 데이터 개수가 32개일 때, 이상적으로 1단계를 거치면 16개 가량의 데이터만 남는다.
2단계를 거치면 8개 가량의 데이터만, 3단계를 거치면 4개 가량의 데이터만 남는 것.
다시 말해 이진 탐색은 탐색 범위를 절반씩 줄이며, **시간 복잡도는 0(log N)**을 보장한다.

## 파이썬 이진 탐색 라이브러리

- bisect_left(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스를 반환
- bisect_right(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스를 반환

```python
from bisect import bisect_left, bisect_right

a = [1,2,4,4,8]
x = 4

# 4라는 원소에 대해서 이진 탐색을 수행하면,
# 4라는 원소가 들어갈 가장 첫번째 위치인 인덱스 2가 반환된다.
print(bisect_left(a, x))

# 4라는 원소에 대해서 이진 탐색을 수행하면,
# 4라는 원소가 들어갈 가장 오른쪽 인덱스인 인덱스 4가 반환된다.
print(bisect_right(a, x))
```

### 실행 결과

```
2
4
```



## 파라메트릭 서치 (Parametric Search)

**파라메트릭 서치**란 <u>최적화 문제를 결정 문제('예' 혹은 '아니오')로 바꾸어 해결하는 기법</u>
	예시 : 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제

일반적으로 코딩 테스트에서 파라메트릭 서치 문제는 **이진 탐색을 이용하여 해결**할 수 있다.