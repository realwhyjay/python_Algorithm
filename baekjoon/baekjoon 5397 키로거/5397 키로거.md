# 백준 5397 : 키로거

#### Date : 21/02/13

#### Lang : Python

#### Question : [백준 5397](https://www.acmicpc.net/problem/5397)


## 1차 답안 (실패)

```python
num = int(input())
left_count = -1

for _ in range(num):
    pw_input = input()
    pw = []
    
    # 입력 받은 pw_input의 값들을 하나하나 조건과 비교하여, 조건에 맞는 경우에는 pw에 append 하도록 해주었다.
    for i in range(len(pw_input)):
        if pw_input[i] == '<': # 입력받은 값이 <일 경우
            if pw_input[i+1] == '<': # 다음 값도 < 일 경우
                left_count += 1
            else:
                if not pw: # 아직 pw에 아무런 값도 append 되지 않은 경우
                    left_count = -1
                    continue
                left_count += 1
		
    # 입력 예시에서는 문제가 되지 않았지만, 만약 이대로 조건을 내버려둔다면
 	  # < 와 겹쳐서 사용될 경우에 문제가 생긴다. 
    # left_count를 - 해주거나 하는 식으로 조건을 걸어주었어야했나...?
        elif pw_input[i] == '>':
            continue

    		# -를 만나는 경우에는 그냥 pop 해준다.
        elif pw_input[i] == '-':
            pw.pop()
        else:
          # left_count가 있는지 없는지에 따라 append 해주는 위치를 정해준다.
            if left_count != -1:
                pw.insert(-1 - left_count, pw_input[i])
                left_count = -1
            else:
                pw.append(pw_input[i])
                left_count = -1
		
    # 결과 출력
    print(''.join(pw))


    # IDE에서는 아주 잘 되지만, 백준에서는 런타임 에러(indexerror)가 뜬다. 
    # 이유를 정말 열심히 찾아봤는데 도대체 알 수가 없어서 머리가 터질지경
```

## 모범 답안 

```python
'''
스스로는 해결할 수 없어서 나동빈님의 코드를 보고 클론코딩했다.
커서를 기준으로 양쪽에 두개의 리스트를 만들고, 
커서가 왼쪽으로 이동하면 왼쪽 리스트의 마지막 원소가 오른쪽에 넘어가고 
커서가 오른쪽으로 이동하면 오른쪽 리스트의 마지막 원소가 왼쪽의 마지막으로 append 되도록 해주었다.
'''
test_case = int(input())

for _ in range(test_case):
    data = input()
    left_stack = []
    right_stack = []

    for i in data:
      # 기본적으로 왼쪽 리스트가 기준이 되기 때문에, -가 입력되는 경우 left에서 pop 해준다.
        if i == '-':
            if left_stack:
                left_stack.pop()
      # 커서를 왼쪽으로 옮기는 경우, 왼쪽 리스트의 원소를 오른쪽으로 append 한다.
        elif i == '<':
            if left_stack:
                right_stack.append(left_stack.pop())  
        
        # 커서를 오른쪽으로 옮기는 경우, 오른쪽 리스트의 원소를 왼쪽으로 append 한다.
        elif i == '>':
            if right_stack:
                left_stack.append(right_stack.pop())
        # 일반적인 값들은 전부 왼쪽 리스트에 append 한다.
        else:
            left_stack.append(i)

    # 오른쪽 리스트에는 원소가 역순으로 쌓여있기 때문에 reversed 해주어야한다.
    left_stack.extend(reversed(right_stack))
    
    # 출력
    print(''.join(left_stack))
```

참고한 설명들 :   
https://assaeunji.github.io/python/2020-05-05-bj5397/
https://chancoding.tistory.com/49