# 백준 2805 : 목재 자르기

#### Date : 21/03/10

#### Lang : Python

#### Question : [백준 2805](https://www.acmicpc.net/problem/2805)

## 최종 답안 (pypy3)

```python
n, m = map(int, input().split())
height = list(map(int, input().split()))
start = 1
end = max(height)
# 원래는 height.sort() 해주고, height[-1]을 end 값으로 줬었다.
# 하지만 max를 활용하면 sort를 해줄 필요가 없다!

while start <= end: 
  	# start값이 end 와 같거나 커질 때 까지 (이분탐색이 끝날 떄까지) while 문을 돌려준다
    mid = (start+end)//2
    result = 0

    for i in height:
      # 각 나무의 높이에서 mid 값을 뺀 뒤, 벌목된 나무의 길이가 총 얼마인지 계산한다.
      # mid 보다 낮은 높이를 가진 나무가 있다면 음수 값이 나오니 (i-mid)>0 이라는 조건을 추가해 주었다.
        if (i-mid) > 0:
            result += (i - mid)

    # 벌목된 나무의 총 길이가 m보다 크다면 mid+1 을 start로 두고,
    # 벌목된 나무의 총 길이가 m 보다 작다면 mid-1 을 end로 둔뒤 while을 반복해준다.
    if result >= m:
        start = mid+1
    else:
        end = mid-1

# start와 end가 같거나 커지면 while문을 탈출하고 결과를 프린트한다.
print(end)

```

python으로 제출하면 시간초과가 뜨길래 여러 블로그를 찾아보니 죄다 pypy3로 제출했더라.  
그래서 나도 pypy3 으로 제출했더니 문제가 해결됐다.  
그래도 뭔가 찝찝해서 python으로는 시간초과를 피할 수 없을지 찾아봤다.  

## python 모범 답안 

```python
n, m = map(int, input().split())
height = list(map(int, input().split()))
start = 1
end = max(height)


while start <= end:
    mid = (start+end)//2
    result = 0
	
    result = sum([i-mid if mid < i else 0 for i in height])

    if result >= m:
        start = mid+1

    else:
        end = mid-1

print(end)

```

문제는 벌목된 나무의 길이를 합쳐주는 for문이었다. (아래의 코드) 

```python
for i in height:
        if (i-mid) > 0:
            result += (i - mid)
```

위의 코드를 아래와 같이 수정해주면 해결된다.  
아직 아래와 같은 '파이썬식 코드'를 쓰는게 어색하고 잘 생각도 못한다.  
어떻게 저런 코드를 바로바로 생각하지.. 어휴    

```python
result = sum([i-mid if mid < i else 0 for i in height])
```

