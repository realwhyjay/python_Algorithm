# 백준 1920 : 수 찾기

#### Date : 21/02/17

#### Lang : Python

#### Question : [백준 1920](https://www.acmicpc.net/problem/1920)


## 1차 답안 (시간 초과)

```python
N = int(input())
Nlist = list(map(int, input().split()))
M = int(input())
Mlist = list(map(int, input().split()))

# count()를 이용하여 Nlist에 Mlist[i]가 한개라도 있다면 1을 출력하도록 해주었다.
# 호기롭게 제출했지만 결과는 시간초과 ㅜ
for i in range(len(Mlist)):
    print(1) if Nlist.count(Mlist[i]) >= 1 else print(0)

```

## 2차 답안 (시간 초과)

```python
# 시간초과의 원인이 입력 문제일 것이라 생각하고, input()을 sys.stdin.readline()로 전부 수정해주었다.
# 하지만 결과는 똑같이 시간초과 ㅠ

import sys

N = int(sys.stdin.readline())
Nlist = set(map(int, sys.stdin.readline().split()))
M = int(sys.stdin.readline())
Mlist = list(map(int, sys.stdin.readline().split()))

for i in range(len(Mlist)):
    print(1) if Nlist.count(Mlist[i]) >= 1 else print(0)
```

## 최종 답안

```python
# 솔루션을 찾아보니 시간초과는 입력 문제가 아닌 자료구조의 차이 때문이었다.
# list의 search 시간복잡도와 set의 search 시간복잡도가 완전 달랐기 때문.
# list는 값이 나올때까지 탐색을 하지만 set의 경우에는 탐색이 필요없다고 한다.

import sys

N = int(sys.stdin.readline())
Nset = set(map(int, sys.stdin.readline().split()))
M = int(sys.stdin.readline())
Mlist = list(map(int, sys.stdin.readline().split()))

# set에는 count()같은 탐색 메소드가 없기 때문에 직접 for문으로 비교해주도록 하였다.
# Mlist의 값이 Nset안에 있는 경우에는 1을, 그렇지 않을 때는 0을 출력하도록 해주었다.
for i in Mlist:
    if i in Nset:
        print(1)
    else :
        print(0)
```

